/**
 * TypeScript bridge to the core UniFFI native module.
 *
 * The native module (generated by UniFFI) is loaded as 'delta_core' via the
 * React Native TurboModule / JSI bridge.  During unit tests or web preview
 * we fall back to a JS stub so the module can be imported without crashing.
 */

import { NativeModules, TurboModuleRegistry } from 'react-native';

export interface KeyPair {
  privateKeyHex: string; // 64 hex chars — Ed25519 private key seed
  publicKeyHex: string;  // 64 hex chars — peer identity
  mnemonic: string;      // 24 space-separated BIP-39 words
}

export class KeyError extends Error {
  constructor(
    public readonly kind: 'InvalidMnemonic' | 'InvalidPrivateKey',
    message: string,
  ) {
    super(message);
    this.name = 'KeyError';
  }
}

// ── Phase 3 types ──────────────────────────────────────────────────────────────

export interface BootstrapNode {
  nodeIdHex: string;
  relayUrl: string;
}

export type ConnectionStatus = 'Online' | 'Connecting' | 'Offline';

/** Hardcoded for launch — update when bootstrap node is deployed. */
export const BOOTSTRAP_NODES: BootstrapNode[] = [
  // { nodeIdHex: '<64-hex-char-ed25519-pubkey>', relayUrl: 'https://relay.delta.app' },
];

// ── Data types ────────────────────────────────────────────────────────────────

export interface Profile {
  publicKey: string;
  username: string;
  avatarBlobId: string | null;
  bio: string | null;
  availableFor: string[];
  isPublic: boolean;
  createdAt: number;
  updatedAt: number;
}

export interface PkarrResolved {
  recordType: string;
  name: string | null;
  username: string | null;
  description: string | null;
  bio: string | null;
  avatarBlobId: string | null;
  coverBlobId: string | null;
  publicKey: string;
}

export interface OnionHopFfi {
  pubkeyHex: string;
  nextUrl: string;
}

export interface OnionPeeled {
  peelType: 'forward' | 'deliver';
  nextHopUrl: string | null;
  innerPacket: Uint8Array | null;
  topicId: Uint8Array | null;
  op: Uint8Array | null;
}

export interface OrgSummary {
  orgId: string;
  name: string;
  typeLabel: string;
  description: string | null;
  avatarBlobId: string | null;
  coverBlobId: string | null;
  isPublic: boolean;
  creatorKey: string;
  createdAt: number;
}

export interface Room {
  roomId: string;
  orgId: string;
  name: string;
  createdBy: string;
  createdAt: number;
  encKeyEpoch: number;
  isArchived: boolean;
  archivedAt: number | null;
}

export interface Message {
  messageId: string;
  roomId: string | null;
  dmThreadId: string | null;
  authorKey: string;
  contentType: string;
  textContent: string | null;
  blobId: string | null;
  embedUrl: string | null;
  mentions: string[];
  replyTo: string | null;
  timestamp: number;
  editedAt: number | null;
  isDeleted: boolean;
}

export interface DmThread {
  threadId: string;
  initiatorKey: string;
  recipientKey: string;
  createdAt: number;
  lastMessageAt: number | null;
}

// ── Phase 5 types ──────────────────────────────────────────────────────────────

export class AuthError extends Error {
  constructor(
    public readonly kind: 'InvalidSignature' | 'TokenExpired' | 'Unauthorized' | 'NotInitialised',
    message: string,
  ) {
    super(message);
    this.name = 'AuthError';
  }
}

export interface InviteTokenInfo {
  orgId: string;
  inviterKey: string;
  accessLevel: string;
  expiryTimestamp: number;
}

export interface MemberInfo {
  publicKey: string;
  accessLevel: string;
  joinedAt: number;
}

// ── Native module interface ───────────────────────────────────────────────────

interface DeltaCoreNative {
  // Phase 1
  generateKeypair(): Promise<KeyPair>;
  importFromMnemonic(words: string[]): Promise<KeyPair>;
  // Phase 2
  initCore(privateKeyHex: string, dbDir: string, bootstrapNodes: BootstrapNode[]): Promise<void>;
  createOrUpdateProfile(username: string, bio: string | null, availableFor: string[], isPublic: boolean): Promise<void>;
  getPkarrUrl(publicKeyHex: string): string;
  resolvePkarr(z32Key: string): Promise<PkarrResolved | null>;
  getMyProfile(): Promise<Profile | null>;
  getProfile(publicKey: string): Promise<Profile | null>;
  createOrg(name: string, typeLabel: string, description: string | null, isPublic: boolean): Promise<string>;
  listMyOrgs(): Promise<OrgSummary[]>;
  updateOrg(orgId: string, name: string | null, typeLabel: string | null, description: string | null, avatarBlobId: string | null, coverBlobId: string | null, isPublic: boolean | null): Promise<void>;
  createRoom(orgId: string, name: string): Promise<string>;
  listRooms(orgId: string, includeArchived: boolean): Promise<Room[]>;
  updateRoom(orgId: string, roomId: string, name: string | null): Promise<void>;
  deleteRoom(orgId: string, roomId: string): Promise<void>;
  archiveRoom(orgId: string, roomId: string): Promise<void>;
  unarchiveRoom(orgId: string, roomId: string): Promise<void>;
  sendMessage(
    roomId: string | null,
    dmThreadId: string | null,
    contentType: string,
    textContent: string | null,
    blobId: string | null,
    embedUrl: string | null,
    mentions: string[],
    replyTo: string | null,
  ): Promise<string>;
  listMessages(
    roomId: string | null,
    dmThreadId: string | null,
    limit: number,
    beforeTimestamp: number | null,
  ): Promise<Message[]>;
  createDmThread(recipientKey: string): Promise<string>;
  listDmThreads(): Promise<DmThread[]>;
  // Phase 3
  getConnectionStatus(): Promise<ConnectionStatus>;
  subscribeRoomTopic(roomId: string): Promise<void>;
  subscribeDmTopic(threadId: string): Promise<void>;
  searchPublicOrgs(query: string): Promise<OrgSummary[]>;
  // Phase 5
  generateInviteToken(orgId: string, accessLevel: string, expiryTimestamp: number): string;
  verifyInviteToken(tokenBase64: string, currentTimestamp: number): InviteTokenInfo;
  addMemberDirect(orgId: string, memberPublicKey: string, accessLevel: string): Promise<void>;
  removeMemberFromOrg(orgId: string, memberPublicKey: string): Promise<void>;
  changeMemberPermission(orgId: string, memberPublicKey: string, newAccessLevel: string): Promise<void>;
  listOrgMembers(orgId: string): Promise<MemberInfo[]>;
  // Phase 7 — binary data is base64-encoded over the RN bridge
  uploadBlob(dataBase64: string, mimeType: string, roomId: string | null): Promise<string>;
  getBlob(blobHash: string): Promise<string>; // returns base64
  // Onion routing — bytes are base64-encoded over the RN bridge
  buildOnionPacket(hops: OnionHopFfi[], topicIdBase64: string, opBase64: string): Promise<string>; // returns base64
  peelOnionLayer(packetBase64: string, recipientSeedHex: string): Promise<{
    peelType: string;
    nextHopUrl: string | null;
    innerPacketBase64: string | null;
    topicIdBase64: string | null;
    opBase64: string | null;
  }>;
}

function loadNative(): DeltaCoreNative {
  try {
    // Prefer TurboModule if available, fallback to legacy NativeModules
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const turbo = (TurboModuleRegistry as any)?.get?.('DeltaCore');
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const legacy = (NativeModules as any)?.DeltaCore;
    const mod = (turbo || legacy) as DeltaCoreNative | undefined;
    if (mod) {
      return mod;
    }
    throw new Error('DeltaCore native module not loaded');
  } catch {
    return {
      async generateKeypair(): Promise<KeyPair> {
        throw new Error('delta_core native module not loaded');
      },
      async importFromMnemonic(_words: string[]): Promise<KeyPair> {
        throw new Error('delta_core native module not loaded');
      },
      async initCore() { throw new Error('delta_core native module not loaded'); },
      async createOrUpdateProfile() { throw new Error('delta_core not loaded'); },
      getPkarrUrl() { throw new Error('delta_core not loaded'); },
      async resolvePkarr() { return null; },
      async getMyProfile() { return null; },
      async getProfile() { return null; },
      async createOrg() { throw new Error('delta_core not loaded'); },
      async listMyOrgs() { return []; },
      async updateOrg() { throw new Error('delta_core not loaded'); },
      async createRoom() { throw new Error('delta_core not loaded'); },
      async listRooms() { return []; },
      async updateRoom() { throw new Error('delta_core not loaded'); },
      async deleteRoom() { throw new Error('delta_core not loaded'); },
      async archiveRoom() { throw new Error('delta_core not loaded'); },
      async unarchiveRoom() { throw new Error('delta_core not loaded'); },
      async sendMessage() { throw new Error('delta_core not loaded'); },
      async listMessages() { return []; },
      async createDmThread() { throw new Error('delta_core not loaded'); },
      async listDmThreads() { return []; },
      async getConnectionStatus() { return 'Offline'; },
      async subscribeRoomTopic() {},
      async subscribeDmTopic() {},
      async searchPublicOrgs() { return []; },
      generateInviteToken() { throw new Error('delta_core not loaded'); },
      verifyInviteToken() { throw new Error('delta_core not loaded'); },
      async addMemberDirect() { throw new Error('delta_core not loaded'); },
      async removeMemberFromOrg() { throw new Error('delta_core not loaded'); },
      async changeMemberPermission() { throw new Error('delta_core not loaded'); },
      async listOrgMembers() { return []; },
      async uploadBlob() { throw new Error('delta_core not loaded'); },
      async getBlob() { throw new Error('delta_core not loaded'); },
      async buildOnionPacket() { throw new Error('delta_core not loaded'); },
      async peelOnionLayer() { throw new Error('delta_core not loaded'); },
    };
  }
}

const native = loadNative();

// ── Phase 1 exports ───────────────────────────────────────────────────────────

/** Generate a fresh Ed25519 keypair and 24-word BIP-39 mnemonic. */
export async function generateKeypair(): Promise<KeyPair> {
  return native.generateKeypair();
}

/**
 * Re-derive a keypair from an existing 24-word mnemonic.
 * Throws {@link KeyError} if the mnemonic is invalid.
 */
export async function importFromMnemonic(words: string[]): Promise<KeyPair> {
  try {
    return await native.importFromMnemonic(words);
  } catch (err: unknown) {
    if (err instanceof Error && err.message.includes('InvalidMnemonic')) {
      throw new KeyError('InvalidMnemonic', err.message);
    }
    throw err;
  }
}

// ── Phase 2/Profile exports ───────────────────────────────────────────────────

export async function createOrUpdateProfile(
  username: string,
  bio: string | null,
  availableFor: string[],
  isPublic: boolean = false,
): Promise<void> {
  return native.createOrUpdateProfile(username, bio, availableFor, isPublic);
}

export function getPkarrUrl(publicKeyHex: string): string {
  try {
    return native.getPkarrUrl(publicKeyHex);
  } catch (err: unknown) {
    if (err instanceof Error) {
      throw new Error(`Failed to get pkarr URL: ${err.message}`);
    }
    throw err;
  }
}

export async function resolvePkarr(z32Key: string): Promise<PkarrResolved | null> {
  return native.resolvePkarr(z32Key);
}

export async function getMyProfile(): Promise<Profile | null> {
  return native.getMyProfile();
}

export async function getProfile(publicKey: string): Promise<Profile | null> {
  return native.getProfile(publicKey);
}

// ── Phase 2/Orgs/Rooms/DMs exports (wrappers over native) ─────────────────────

export async function createOrg(
  name: string,
  typeLabel: string,
  description: string | null,
  isPublic: boolean,
): Promise<string> {
  return native.createOrg(name, typeLabel, description, isPublic);
}

export async function listMyOrgs(): Promise<OrgSummary[]> {
  return native.listMyOrgs();
}

export async function updateOrg(
  orgId: string,
  name: string | null = null,
  typeLabel: string | null = null,
  description: string | null = null,
  avatarBlobId: string | null = null,
  coverBlobId: string | null = null,
  isPublic: boolean | null = null,
): Promise<void> {
  return native.updateOrg(orgId, name, typeLabel, description, avatarBlobId, coverBlobId, isPublic);
}

export async function createRoom(orgId: string, name: string): Promise<string> {
  return native.createRoom(orgId, name);
}

export async function listRooms(orgId: string, includeArchived: boolean = false): Promise<Room[]> {
  return native.listRooms(orgId, includeArchived);
}

export async function updateRoom(orgId: string, roomId: string, name: string | null = null): Promise<void> {
  return native.updateRoom(orgId, roomId, name);
}

export async function deleteRoom(orgId: string, roomId: string): Promise<void> {
  return native.deleteRoom(orgId, roomId);
}

export async function archiveRoom(orgId: string, roomId: string): Promise<void> {
  return native.archiveRoom(orgId, roomId);
}

export async function unarchiveRoom(orgId: string, roomId: string): Promise<void> {
  return native.unarchiveRoom(orgId, roomId);
}

export async function sendMessage(
  roomId: string | null,
  dmThreadId: string | null,
  contentType: string,
  textContent: string | null,
  blobId: string | null,
  embedUrl: string | null,
  mentions: string[],
  replyTo: string | null,
): Promise<string> {
  return native.sendMessage(roomId, dmThreadId, contentType, textContent, blobId, embedUrl, mentions, replyTo);
}

export async function listMessages(
  roomId: string | null,
  dmThreadId: string | null,
  limit: number,
  beforeTimestamp: number | null,
): Promise<Message[]> {
  return native.listMessages(roomId, dmThreadId, limit, beforeTimestamp);
}

export async function createDmThread(recipientKey: string): Promise<string> {
  return native.createDmThread(recipientKey);
}

export async function listDmThreads(): Promise<DmThread[]> {
  return native.listDmThreads();
}

// ── Phase 3 exports ───────────────────────────────────────────────────────────

export async function initCore(
  privateKeyHex: string,
  bootstrapNodes: BootstrapNode[] = BOOTSTRAP_NODES,
): Promise<void> {
  return native.initCore(privateKeyHex, '', bootstrapNodes);
}

export async function getConnectionStatus(): Promise<ConnectionStatus> {
  return native.getConnectionStatus();
}

export async function subscribeRoomTopic(roomId: string): Promise<void> {
  return native.subscribeRoomTopic(roomId);
}

export async function subscribeDmTopic(threadId: string): Promise<void> {
  return native.subscribeDmTopic(threadId);
}

export async function searchPublicOrgs(query: string): Promise<OrgSummary[]> {
  return native.searchPublicOrgs(query);
}

// ── Phase 5 exports ───────────────────────────────────────────────────────────

export function generateInviteToken(
  orgId: string,
  accessLevel: string,
  expiryTimestamp: number,
): string {
  try {
    return native.generateInviteToken(orgId, accessLevel, expiryTimestamp);
  } catch (err: unknown) {
    if (err instanceof Error && err.message.includes('Unauthorized')) {
      throw new AuthError('Unauthorized', err.message);
    }
    throw err;
  }
}

export function verifyInviteToken(
  tokenBase64: string,
  currentTimestamp: number,
): InviteTokenInfo {
  try {
    return native.verifyInviteToken(tokenBase64, currentTimestamp);
  } catch (err: unknown) {
    if (err instanceof Error) {
      if (err.message.includes('InvalidSignature')) {
        throw new AuthError('InvalidSignature', err.message);
      }
      if (err.message.includes('TokenExpired')) {
        throw new AuthError('TokenExpired', err.message);
      }
    }
    throw err;
  }
}

export async function addMemberDirect(
  orgId: string,
  memberPublicKey: string,
  accessLevel: string,
): Promise<void> {
  return native.addMemberDirect(orgId, memberPublicKey, accessLevel);
}

export async function removeMemberFromOrg(
  orgId: string,
  memberPublicKey: string,
): Promise<void> {
  return native.removeMemberFromOrg(orgId, memberPublicKey);
}

export async function changeMemberPermission(
  orgId: string,
  memberPublicKey: string,
  newAccessLevel: string,
): Promise<void> {
  return native.changeMemberPermission(orgId, memberPublicKey, newAccessLevel);
}

export async function listOrgMembers(orgId: string): Promise<MemberInfo[]> {
  return native.listOrgMembers(orgId);
}

// ── Phase 7: Blobs ────────────────────────────────────────────────────────────

export class BlobError extends Error {
  constructor(
    public readonly kind: 'NotInitialized' | 'NotFound' | 'StoreError' | 'IoError',
    message: string,
  ) {
    super(message);
    this.name = 'BlobError';
  }
}

export async function uploadBlob(
  data: Uint8Array,
  mimeType: string,
  roomId: string | null,
): Promise<string> {
  let binary = '';
  for (let i = 0; i < data.byteLength; i++) { binary += String.fromCharCode(data[i]); }
  return native.uploadBlob(btoa(binary), mimeType, roomId);
}

export async function getBlob(blobHash: string): Promise<Uint8Array> {
  const base64 = await native.getBlob(blobHash);
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) { bytes[i] = binary.charCodeAt(i); }
  return bytes;
}

// ── Onion routing ─────────────────────────────────────────────────────────────

function bytesToBase64(bytes: Uint8Array): string {
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) { binary += String.fromCharCode(bytes[i]); }
  return btoa(binary);
}

function base64ToBytes(base64: string): Uint8Array {
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) { bytes[i] = binary.charCodeAt(i); }
  return bytes;
}

export async function buildOnionPacket(
  hops: OnionHopFfi[],
  topicId: Uint8Array,
  op: Uint8Array,
): Promise<Uint8Array> {
  const base64 = await native.buildOnionPacket(hops, bytesToBase64(topicId), bytesToBase64(op));
  return base64ToBytes(base64);
}

export async function peelOnionLayer(
  packet: Uint8Array,
  recipientSeedHex: string,
): Promise<OnionPeeled> {
  const raw = await native.peelOnionLayer(bytesToBase64(packet), recipientSeedHex);
  return {
    peelType: raw.peelType as 'forward' | 'deliver',
    nextHopUrl: raw.nextHopUrl,
    innerPacket: raw.innerPacketBase64 ? base64ToBytes(raw.innerPacketBase64) : null,
    topicId: raw.topicIdBase64 ? base64ToBytes(raw.topicIdBase64) : null,
    op: raw.opBase64 ? base64ToBytes(raw.opBase64) : null,
  };
}
